/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./RoomAvailabilityMapAndRouter/HelloWorld.tsx":
/*!*****************************************************!*\
  !*** ./RoomAvailabilityMapAndRouter/HelloWorld.tsx ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.HelloWorld = void 0;\nvar React = __webpack_require__(/*! react */ \"react\");\n__webpack_require__(/*! ./styles.css */ \"./RoomAvailabilityMapAndRouter/styles.css\");\nvar Hammer = __webpack_require__(/*! hammerjs */ \"./node_modules/hammerjs/hammer.js\");\n// import Hammer from \"hammerjs\";\nvar svgPanZoom = __webpack_require__(/*! svg-pan-zoom */ \"./node_modules/svg-pan-zoom/src/browserify.js\");\nvar eventsHandler = {\n  haltEventListeners: [\"touchstart\", \"touchend\", \"touchmove\", \"touchleave\", \"touchcancel\"],\n  init: function init(options) {\n    var instance = options.instance,\n      initialScale = 1,\n      pannedX = 0,\n      pannedY = 0;\n    // Init Hammer\n    // Listen only for pointer and touch events\n    // https://www.npmjs.com/package/@types/hammerjs\n    // https://github.com/hammerjs/hammer.js/issues/1084\n    window.hammer = new Hammer(options.svgElement, {\n      inputClass: Hammer.TouchMouseInput ? Hammer.PointerEventInput : Hammer.TouchInput\n    });\n    // Enable pinch\n    window.hammer.get(\"pinch\").set({\n      enable: true\n    });\n    // Handle double tap\n    window.hammer.on(\"doubletap\", function (ev) {\n      instance.zoomIn();\n    });\n    // Handle pan\n    window.hammer.on(\"panstart panmove\", function (ev) {\n      // On pan start reset panned variables\n      if (ev.type === \"panstart\") {\n        pannedX = 0;\n        pannedY = 0;\n      }\n      // Pan only the difference\n      instance.panBy({\n        x: ev.deltaX - pannedX,\n        y: ev.deltaY - pannedY\n      });\n      pannedX = ev.deltaX;\n      pannedY = ev.deltaY;\n    });\n    // Handle pinch\n    window.hammer.on(\"pinchstart pinchmove\", function (ev) {\n      // On pinch start remember initial zoom\n      if (ev.type === \"pinchstart\") {\n        initialScale = instance.getZoom();\n        instance.zoomAtPoint(initialScale * ev.scale, {\n          x: ev.center.x,\n          y: ev.center.y\n        });\n      }\n      instance.zoomAtPoint(initialScale * ev.scale, {\n        x: ev.center.x,\n        y: ev.center.y\n      });\n    });\n    // Prevent moving the page on some devices when panning over SVG\n    options.svgElement.addEventListener(\"touchmove\", function (e) {\n      e.preventDefault();\n    });\n  },\n  destroy: function destroy() {\n    window.hammer.destroy();\n  }\n};\nvar HelloWorld = /** @class */function (_super) {\n  __extends(HelloWorld, _super);\n  function HelloWorld(props) {\n    return _super.call(this, props) || this;\n    // Initializing the state\n    //window.state = { color: \"lightgreen\" };\n  }\n\n  HelloWorld.prototype.componentDidMount = function () {\n    // https://www.geeksforgeeks.org/reactjs-componentdidmount-method/\n    // Changing the state after 2 sec\n    // from the time when the component\n    // is\n    window.panZoom = svgPanZoom(\"#svg-id\", {\n      zoomEnabled: true,\n      controlIconsEnabled: false,\n      fit: true,\n      center: true,\n      //maxZoom: 5,\n      preventMouseEventsDefault: false,\n      customEventsHandler: eventsHandler\n    });\n    /*\r\n    setTimeout(() => {\r\n      window.setState({ color: \"wheat\" });\r\n    }, 2000);\r\n    */\n    window.panZoom.zoom(0.8);\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n    var myMoveButton = document.getElementById(\"move\");\n    var myResetButton = document.getElementById(\"reset\");\n    if (myMoveButton) {\n      myMoveButton.addEventListener(\"click\", onMoveButtonclick, false);\n    }\n    function onMoveButtonclick(event) {\n      console.log(window.name); // undefined, as `this` is the element\n      //$(\"#reset\").click();\n      if (myResetButton) {\n        myResetButton.click();\n      }\n      //var bb = $(\"#target\")[0].getBBox();\n      var target = document.querySelector(\"#target\");\n      if (target) {\n        var bb = target.getBBox();\n        var vbb = window.panZoom.getSizes().viewBox;\n        var x = vbb.width / 2 - bb.x - bb.width / 2;\n        var y = vbb.height / 2 - bb.y - bb.height / 2;\n        var rz = window.panZoom.getSizes().realZoom;\n        var zoom = vbb.width / bb.width;\n        window.panZoom.panBy({\n          x: x * rz,\n          y: y * rz\n        });\n        window.panZoom.zoom(zoom);\n      }\n    }\n    if (myResetButton) {\n      myResetButton.addEventListener(\"click\", function () {\n        window.panZoom.fit();\n        window.panZoom.center();\n        window.panZoom.zoom(1);\n      });\n    }\n    var elementsArray = document.querySelectorAll(\"rect\");\n    elementsArray.forEach(function (elem) {\n      elem.addEventListener(\"click\", function (event) {\n        console.log(\"this is working\");\n        console.log(event); // undefined, as `this` is the element\n        //$(\"#reset\").click();\n        if (myResetButton) {\n          myResetButton.click();\n        }\n        //var bb = $(\"#target\")[0].getBBox();\n        //var bb = document.querySelector(\"#target\").getBBox();\n        var bb = null;\n        if (event.target) {\n          bb = event.target.getBBox();\n          console.log(event.target);\n          var vbb = window.panZoom.getSizes().viewBox;\n          var x = vbb.width / 2 - bb.x - bb.width / 2;\n          var y = vbb.height / 2 - bb.y - bb.height / 2;\n          var rz = window.panZoom.getSizes().realZoom;\n          var zoom = vbb.width / bb.width;\n          window.panZoom.panBy({\n            x: x * rz,\n            y: y * rz\n          });\n          window.panZoom.zoom(zoom);\n          window.panZoom.zoom(1.5);\n          // This function does stuff\n        }\n      });\n    });\n  };\n\n  HelloWorld.prototype.render = function () {\n    return React.createElement(\"div\", null, React.createElement(\"div\", {\n      id: \"container\",\n      style: {\n        width: \"300px\",\n        height: \"300px\"\n        //border: \"1px solid black\"\n      }\n    }, React.createElement(\"svg\", {\n      id: \"svg-id\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      version: \"1.1\"\n    }, React.createElement(\"rect\", {\n      x: \"0\",\n      y: \"0\",\n      width: \"50\",\n      height: \"50\",\n      fill: \"#00f\"\n    }), React.createElement(\"rect\", {\n      x: \"200\",\n      y: \"0\",\n      width: \"50\",\n      height: \"50\",\n      fill: \"#00f\"\n    }), React.createElement(\"rect\", {\n      x: \"0\",\n      y: \"200\",\n      width: \"50\",\n      height: \"50\",\n      fill: \"#0ff\",\n      id: \"target\"\n    }), React.createElement(\"rect\", {\n      x: \"200\",\n      y: \"200\",\n      width: \"50\",\n      height: \"50\",\n      fill: \"#f00\"\n    })), React.createElement(\"button\", {\n      id: \"move\"\n    }, \"Zoom to Target\"), React.createElement(\"button\", {\n      id: \"reset\"\n    }, \"Reset\"), React.createElement(\"p\", null, \"        \", this.props.name)));\n  };\n  return HelloWorld;\n}(React.Component);\nexports.HelloWorld = HelloWorld;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./RoomAvailabilityMapAndRouter/HelloWorld.tsx?");

/***/ }),

/***/ "./RoomAvailabilityMapAndRouter/index.ts":
/*!***********************************************!*\
  !*** ./RoomAvailabilityMapAndRouter/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.RoomAvailabilityMapAndRouter = void 0;\nvar HelloWorld_1 = __webpack_require__(/*! ./HelloWorld */ \"./RoomAvailabilityMapAndRouter/HelloWorld.tsx\");\nvar React = __webpack_require__(/*! react */ \"react\");\nvar RoomAvailabilityMapAndRouter = /** @class */function () {\n  /**\r\n   * Empty constructor.\r\n   */\n  function RoomAvailabilityMapAndRouter() {\n    this.zoomLevel = 1;\n    this.tscale = 2;\n  }\n  /**\r\n   * Used to initialize the control instance. Controls can kick off remote server calls and other initialization actions here.\r\n   * Data-set values are not initialized here, use updateView.\r\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to property names defined in the manifest, as well as utility functions.\r\n   * @param notifyOutputChanged A callback method to alert the framework that the control has new outputs ready to be retrieved asynchronously.\r\n   * @param state A piece of data that persists in one session for a single user. Can be set at any point in a controls life cycle by calling 'setControlState' in the Mode interface.\r\n   */\n  RoomAvailabilityMapAndRouter.prototype.init = function (context, notifyOutputChanged, state) {\n    this.notifyOutputChanged = notifyOutputChanged;\n  };\n  /**\r\n   * Called when any value in the property bag has changed. This includes field values, data-sets, global values such as container height and width, offline status, control metadata values such as label, visible, etc.\r\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to names defined in the manifest, as well as utility functions\r\n   * @returns ReactElement root react element for the control\r\n   */\n  RoomAvailabilityMapAndRouter.prototype.updateView = function (context) {\n    var props = {\n      name: 'Hello, World!'\n    };\n    return React.createElement(HelloWorld_1.HelloWorld, props);\n  };\n  /**\r\n   * It is called by the framework prior to a control receiving new data.\r\n   * @returns an object based on nomenclature defined in manifest, expecting object[s] for property marked as “bound” or “output”\r\n   */\n  RoomAvailabilityMapAndRouter.prototype.getOutputs = function () {\n    return {};\n  };\n  /**\r\n   * Called when the control is to be removed from the DOM tree. Controls should use this call for cleanup.\r\n   * i.e. cancelling any pending remote calls, removing listeners, etc.\r\n   */\n  RoomAvailabilityMapAndRouter.prototype.destroy = function () {\n    // Add code to cleanup control if necessary\n  };\n  return RoomAvailabilityMapAndRouter;\n}();\nexports.RoomAvailabilityMapAndRouter = RoomAvailabilityMapAndRouter;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./RoomAvailabilityMapAndRouter/index.ts?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/hammerjs/hammer.js":
/*!*****************************************!*\
  !*** ./node_modules/hammerjs/hammer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n  function each(obj, iterator, context) {\n    var i;\n    if (!obj) {\n      return;\n    }\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n      return method.apply(this, arguments);\n    };\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n  var assign;\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n      var output = Object(target);\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n      i++;\n    }\n    return dest;\n  }, 'extend', 'Use `assign`.');\n\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n      childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n  }\n\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n        i++;\n      }\n      return -1;\n    }\n  }\n\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n      values[i] = val;\n      i++;\n    }\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n    return results;\n  }\n\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n      if (prop in obj) {\n        return prop;\n      }\n      i++;\n    }\n    return undefined;\n  }\n\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n  var _uniqueId = 1;\n  function uniqueId() {\n    return _uniqueId++;\n  }\n\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = ('ontouchstart' in window);\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n    this.init();\n  }\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function handler() {},\n    /**\n     * bind the events\n     */\n    init: function init() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n    /**\n     * unbind the events\n     */\n    destroy: function destroy() {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n    return new Type(manager, inputHandler);\n  }\n\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n    if (isFirst) {\n      manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n    input.target = target;\n  }\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n      deltaTime = input.timeStamp - last.timeStamp,\n      velocity,\n      velocityX,\n      velocityY,\n      direction;\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n  function getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n    var x = 0,\n      y = 0,\n      i = 0;\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type];\n\n      // on start we want to have the left mouse button down\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      }\n\n      // mouse must be down\n      if (!this.pressed) {\n        return;\n      }\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  };\n\n  // in IE10 the pointer types is defined as an enum\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n  };\n\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n  // IE10 has prefixed support, and case-sensitive\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\n      // get index of the event in the store\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n      // start and mouse must be down\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      }\n\n      // it not found, so the pointer hasn't been down (so it's probably a hover)\n      if (storeIndex < 0) {\n        return;\n      }\n\n      // update the event in the store\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n      // should we handle the touch events?\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n      if (!this.started) {\n        return;\n      }\n      var touches = normalizeSingleTouches.call(this, ev, type);\n\n      // when done, reset the started state\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n    return [all, changed];\n  }\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n      if (!touches) {\n        return;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n    var i,\n      targetTouches,\n      changedTouches = toArray(ev.changedTouches),\n      changedTargetTouches = [],\n      target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n      i = 0;\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      }\n\n      // cleanup removed touches\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n      i++;\n    }\n    if (!changedTargetTouches.length) {\n      return;\n    }\n    return [\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      }\n\n      // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n      this.callback(manager, inputEvent, inputData);\n    },\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n      var removeLastTouch = function removeLastTouch() {\n        var i = lts.indexOf(lastTouch);\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n      y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n        dy = Math.abs(y - t.y);\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n  // magical touchAction value\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function set(value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n      this.actions = value.toLowerCase().trim();\n    },\n    /**\n     * just re-set the touchAction value\n     */\n    update: function update() {\n      this.set(this.manager.options.touchAction);\n    },\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function compute() {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function preventDefaults(input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection;\n\n      // if the touch action did prevented once this session\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function preventSrc(srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n    return TOUCH_ACTION_AUTO;\n  }\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function set(options) {\n      assign(this.options, options);\n\n      // also update the touchAction, in case something changed about the directions/enabled state\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function recognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n      return this;\n    },\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function requireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n      return this;\n    },\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n      return this;\n    },\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function hasRequireFailures() {\n      return this.requireFail.length > 0;\n    },\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function emit(input) {\n      var self = this;\n      var state = this.state;\n      function emit(event) {\n        self.manager.emit(event, input);\n      }\n\n      // 'panstart' and 'panmove'\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      }\n\n      // panend and pancancel\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function tryEmit(input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      }\n      // it's failing anyway\n      this.state = STATE_FAILED;\n    },\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function canEmit() {\n      var i = 0;\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n        i++;\n      }\n      return true;\n    },\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData);\n\n      // is is enabled and allow recognizing?\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      }\n\n      // reset when we've reached the end\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n      this.state = this.process(inputDataClone);\n\n      // the recognizer has recognized a gesture\n      // so trigger an event\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function process(inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function getTouchAction() {},\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function reset() {}\n  };\n\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n    return '';\n  }\n\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n    return '';\n  }\n\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n  }\n\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function attrTest(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function process(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input);\n\n      // on cancel input and we've recognized before, return STATE_CANCELLED\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n        return state | STATE_CHANGED;\n      }\n      return STATE_FAILED;\n    }\n  });\n\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function getTouchAction() {\n      var direction = this.options.direction;\n      var actions = [];\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n      return actions;\n    },\n    directionTest: function directionTest(input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY;\n\n      // lock to axis?\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function attrTest(input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function emit(input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function emit(input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input;\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function getTouchAction() {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function attrTest(input) {\n      var direction = this.options.direction;\n      var velocity;\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function emit(input) {\n      var direction = directionStr(input.offsetDirection);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n      this.manager.emit(this.options.event, input);\n    }\n  });\n\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      }\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n        this._input = input;\n\n        // if tap count matches we have recognized it,\n        // else it has began recognizing...\n        var tapCount = this.count % options.taps;\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n      return STATE_FAILED;\n    },\n    failTimeout: function failTimeout() {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit() {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n\n  /**\n   * @const {string}\n   */\n  Hammer.VERSION = '2.0.7';\n\n  /**\n   * default settings\n   * @namespace\n   */\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function set(options) {\n      assign(this.options, options);\n\n      // Options that need a little more setup\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n      return this;\n    },\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function stop(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      var session = this.session;\n      if (session.stopped) {\n        return;\n      }\n\n      // run the touch-action polyfill\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers;\n\n      // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n      var curRecognizer = session.curRecognizer;\n\n      // reset when the last recognizer is recognized\n      // or when we're in a new session\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n      var i = 0;\n      while (i < recognizers.length) {\n        recognizer = recognizers[i];\n\n        // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n        if (session.stopped !== FORCED_STOP && (\n        // 1\n        !curRecognizer || recognizer == curRecognizer ||\n        // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        }\n\n        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n        i++;\n      }\n    },\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function get(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n      var recognizers = this.recognizers;\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n      return null;\n    },\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function add(recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      }\n\n      // remove existing\n      var existing = this.get(recognizer.options.event);\n      if (existing) {\n        this.remove(existing);\n      }\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function remove(recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n      recognizer = this.get(recognizer);\n\n      // let's make sure this recognizer exists\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n      return this;\n    },\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function on(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      if (handler === undefined) {\n        return;\n      }\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function off(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function emit(event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      }\n\n      // no handlers, so skip it all\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n      if (!handlers || !handlers.length) {\n        return;\n      }\n      data.type = event;\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n      var i = 0;\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function destroy() {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n      return;\n    }\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  });\n\n  // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n  freeGlobal.Hammer = Hammer;\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, document, 'Hammer');\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/hammerjs/hammer.js?");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/browserify.js":
/*!*****************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/browserify.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var SvgPanZoom = __webpack_require__(/*! ./svg-pan-zoom.js */ \"./node_modules/svg-pan-zoom/src/svg-pan-zoom.js\");\nmodule.exports = SvgPanZoom;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/svg-pan-zoom/src/browserify.js?");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/control-icons.js":
/*!********************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/control-icons.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var SvgUtils = __webpack_require__(/*! ./svg-utilities */ \"./node_modules/svg-pan-zoom/src/svg-utilities.js\");\nmodule.exports = {\n  enable: function enable(instance) {\n    // Select (and create if necessary) defs\n    var defs = instance.svg.querySelector(\"defs\");\n    if (!defs) {\n      defs = document.createElementNS(SvgUtils.svgNS, \"defs\");\n      instance.svg.appendChild(defs);\n    }\n\n    // Check for style element, and create it if it doesn't exist\n    var styleEl = defs.querySelector(\"style#svg-pan-zoom-controls-styles\");\n    if (!styleEl) {\n      var style = document.createElementNS(SvgUtils.svgNS, \"style\");\n      style.setAttribute(\"id\", \"svg-pan-zoom-controls-styles\");\n      style.setAttribute(\"type\", \"text/css\");\n      style.textContent = \".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }\";\n      defs.appendChild(style);\n    }\n\n    // Zoom Group\n    var zoomGroup = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomGroup.setAttribute(\"id\", \"svg-pan-zoom-controls\");\n    zoomGroup.setAttribute(\"transform\", \"translate(\" + (instance.width - 70) + \" \" + (instance.height - 76) + \") scale(0.75)\");\n    zoomGroup.setAttribute(\"class\", \"svg-pan-zoom-control\");\n\n    // Control elements\n    zoomGroup.appendChild(this._createZoomIn(instance));\n    zoomGroup.appendChild(this._createZoomReset(instance));\n    zoomGroup.appendChild(this._createZoomOut(instance));\n\n    // Finally append created element\n    instance.svg.appendChild(zoomGroup);\n\n    // Cache control instance\n    instance.controlIcons = zoomGroup;\n  },\n  _createZoomIn: function _createZoomIn(instance) {\n    var zoomIn = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomIn.setAttribute(\"id\", \"svg-pan-zoom-zoom-in\");\n    zoomIn.setAttribute(\"transform\", \"translate(30.5 5) scale(0.015)\");\n    zoomIn.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomIn.addEventListener(\"click\", function () {\n      instance.getPublicInstance().zoomIn();\n    }, false);\n    zoomIn.addEventListener(\"touchstart\", function () {\n      instance.getPublicInstance().zoomIn();\n    }, false);\n    var zoomInBackground = document.createElementNS(SvgUtils.svgNS, \"rect\"); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomInBackground.setAttribute(\"x\", \"0\");\n    zoomInBackground.setAttribute(\"y\", \"0\");\n    zoomInBackground.setAttribute(\"width\", \"1500\"); // larger than expected because the whole group is transformed to scale down\n    zoomInBackground.setAttribute(\"height\", \"1400\");\n    zoomInBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomIn.appendChild(zoomInBackground);\n    var zoomInShape = document.createElementNS(SvgUtils.svgNS, \"path\");\n    zoomInShape.setAttribute(\"d\", \"M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z\");\n    zoomInShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomIn.appendChild(zoomInShape);\n    return zoomIn;\n  },\n  _createZoomReset: function _createZoomReset(instance) {\n    // reset\n    var resetPanZoomControl = document.createElementNS(SvgUtils.svgNS, \"g\");\n    resetPanZoomControl.setAttribute(\"id\", \"svg-pan-zoom-reset-pan-zoom\");\n    resetPanZoomControl.setAttribute(\"transform\", \"translate(5 35) scale(0.4)\");\n    resetPanZoomControl.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    resetPanZoomControl.addEventListener(\"click\", function () {\n      instance.getPublicInstance().reset();\n    }, false);\n    resetPanZoomControl.addEventListener(\"touchstart\", function () {\n      instance.getPublicInstance().reset();\n    }, false);\n    var resetPanZoomControlBackground = document.createElementNS(SvgUtils.svgNS, \"rect\"); // TODO change these background space fillers to rounded rectangles so they look prettier\n    resetPanZoomControlBackground.setAttribute(\"x\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"y\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"width\", \"182\"); // larger than expected because the whole group is transformed to scale down\n    resetPanZoomControlBackground.setAttribute(\"height\", \"58\");\n    resetPanZoomControlBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    resetPanZoomControl.appendChild(resetPanZoomControlBackground);\n    var resetPanZoomControlShape1 = document.createElementNS(SvgUtils.svgNS, \"path\");\n    resetPanZoomControlShape1.setAttribute(\"d\", \"M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z\");\n    resetPanZoomControlShape1.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    resetPanZoomControl.appendChild(resetPanZoomControlShape1);\n    var resetPanZoomControlShape2 = document.createElementNS(SvgUtils.svgNS, \"path\");\n    resetPanZoomControlShape2.setAttribute(\"d\", \"M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z\");\n    resetPanZoomControlShape2.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    resetPanZoomControl.appendChild(resetPanZoomControlShape2);\n    return resetPanZoomControl;\n  },\n  _createZoomOut: function _createZoomOut(instance) {\n    // zoom out\n    var zoomOut = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomOut.setAttribute(\"id\", \"svg-pan-zoom-zoom-out\");\n    zoomOut.setAttribute(\"transform\", \"translate(30.5 70) scale(0.015)\");\n    zoomOut.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomOut.addEventListener(\"click\", function () {\n      instance.getPublicInstance().zoomOut();\n    }, false);\n    zoomOut.addEventListener(\"touchstart\", function () {\n      instance.getPublicInstance().zoomOut();\n    }, false);\n    var zoomOutBackground = document.createElementNS(SvgUtils.svgNS, \"rect\"); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomOutBackground.setAttribute(\"x\", \"0\");\n    zoomOutBackground.setAttribute(\"y\", \"0\");\n    zoomOutBackground.setAttribute(\"width\", \"1500\"); // larger than expected because the whole group is transformed to scale down\n    zoomOutBackground.setAttribute(\"height\", \"1400\");\n    zoomOutBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomOut.appendChild(zoomOutBackground);\n    var zoomOutShape = document.createElementNS(SvgUtils.svgNS, \"path\");\n    zoomOutShape.setAttribute(\"d\", \"M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z\");\n    zoomOutShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomOut.appendChild(zoomOutShape);\n    return zoomOut;\n  },\n  disable: function disable(instance) {\n    if (instance.controlIcons) {\n      instance.controlIcons.parentNode.removeChild(instance.controlIcons);\n      instance.controlIcons = null;\n    }\n  }\n};\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/svg-pan-zoom/src/control-icons.js?");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/shadow-viewport.js":
/*!**********************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/shadow-viewport.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var SvgUtils = __webpack_require__(/*! ./svg-utilities */ \"./node_modules/svg-pan-zoom/src/svg-utilities.js\"),\n  Utils = __webpack_require__(/*! ./utilities */ \"./node_modules/svg-pan-zoom/src/utilities.js\");\nvar ShadowViewport = function ShadowViewport(viewport, options) {\n  this.init(viewport, options);\n};\n\n/**\n * Initialization\n *\n * @param  {SVGElement} viewport\n * @param  {Object} options\n */\nShadowViewport.prototype.init = function (viewport, options) {\n  // DOM Elements\n  this.viewport = viewport;\n  this.options = options;\n\n  // State cache\n  this.originalState = {\n    zoom: 1,\n    x: 0,\n    y: 0\n  };\n  this.activeState = {\n    zoom: 1,\n    x: 0,\n    y: 0\n  };\n  this.updateCTMCached = Utils.proxy(this.updateCTM, this);\n\n  // Create a custom requestAnimationFrame taking in account refreshRate\n  this.requestAnimationFrame = Utils.createRequestAnimationFrame(this.options.refreshRate);\n\n  // ViewBox\n  this.viewBox = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  this.cacheViewBox();\n\n  // Process CTM\n  var newCTM = this.processCTM();\n\n  // Update viewport CTM and cache zoom and pan\n  this.setCTM(newCTM);\n\n  // Update CTM in this frame\n  this.updateCTM();\n};\n\n/**\n * Cache initial viewBox value\n * If no viewBox is defined, then use viewport size/position instead for viewBox values\n */\nShadowViewport.prototype.cacheViewBox = function () {\n  var svgViewBox = this.options.svg.getAttribute(\"viewBox\");\n  if (svgViewBox) {\n    var viewBoxValues = svgViewBox.split(/[\\s\\,]/).filter(function (v) {\n      return v;\n    }).map(parseFloat);\n\n    // Cache viewbox x and y offset\n    this.viewBox.x = viewBoxValues[0];\n    this.viewBox.y = viewBoxValues[1];\n    this.viewBox.width = viewBoxValues[2];\n    this.viewBox.height = viewBoxValues[3];\n    var zoom = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);\n\n    // Update active state\n    this.activeState.zoom = zoom;\n    this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;\n    this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;\n\n    // Force updating CTM\n    this.updateCTMOnNextFrame();\n    this.options.svg.removeAttribute(\"viewBox\");\n  } else {\n    this.simpleViewBoxCache();\n  }\n};\n\n/**\n * Recalculate viewport sizes and update viewBox cache\n */\nShadowViewport.prototype.simpleViewBoxCache = function () {\n  var bBox = this.viewport.getBBox();\n  this.viewBox.x = bBox.x;\n  this.viewBox.y = bBox.y;\n  this.viewBox.width = bBox.width;\n  this.viewBox.height = bBox.height;\n};\n\n/**\n * Returns a viewbox object. Safe to alter\n *\n * @return {Object} viewbox object\n */\nShadowViewport.prototype.getViewBox = function () {\n  return Utils.extend({}, this.viewBox);\n};\n\n/**\n * Get initial zoom and pan values. Save them into originalState\n * Parses viewBox attribute to alter initial sizes\n *\n * @return {CTM} CTM object based on options\n */\nShadowViewport.prototype.processCTM = function () {\n  var newCTM = this.getCTM();\n  if (this.options.fit || this.options.contain) {\n    var newScale;\n    if (this.options.fit) {\n      newScale = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);\n    } else {\n      newScale = Math.max(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);\n    }\n    newCTM.a = newScale; //x-scale\n    newCTM.d = newScale; //y-scale\n    newCTM.e = -this.viewBox.x * newScale; //x-transform\n    newCTM.f = -this.viewBox.y * newScale; //y-transform\n  }\n\n  if (this.options.center) {\n    var offsetX = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) * 0.5,\n      offsetY = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) * 0.5;\n    newCTM.e = offsetX;\n    newCTM.f = offsetY;\n  }\n\n  // Cache initial values. Based on activeState and fix+center opitons\n  this.originalState.zoom = newCTM.a;\n  this.originalState.x = newCTM.e;\n  this.originalState.y = newCTM.f;\n  return newCTM;\n};\n\n/**\n * Return originalState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getOriginalState = function () {\n  return Utils.extend({}, this.originalState);\n};\n\n/**\n * Return actualState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getState = function () {\n  return Utils.extend({}, this.activeState);\n};\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getZoom = function () {\n  return this.activeState.zoom;\n};\n\n/**\n * Get zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getRelativeZoom = function () {\n  return this.activeState.zoom / this.originalState.zoom;\n};\n\n/**\n * Compute zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.computeRelativeZoom = function (scale) {\n  return scale / this.originalState.zoom;\n};\n\n/**\n * Get pan\n *\n * @return {Object}\n */\nShadowViewport.prototype.getPan = function () {\n  return {\n    x: this.activeState.x,\n    y: this.activeState.y\n  };\n};\n\n/**\n * Return cached viewport CTM value that can be safely modified\n *\n * @return {SVGMatrix}\n */\nShadowViewport.prototype.getCTM = function () {\n  var safeCTM = this.options.svg.createSVGMatrix();\n\n  // Copy values manually as in FF they are not itterable\n  safeCTM.a = this.activeState.zoom;\n  safeCTM.b = 0;\n  safeCTM.c = 0;\n  safeCTM.d = this.activeState.zoom;\n  safeCTM.e = this.activeState.x;\n  safeCTM.f = this.activeState.y;\n  return safeCTM;\n};\n\n/**\n * Set a new CTM\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.setCTM = function (newCTM) {\n  var willZoom = this.isZoomDifferent(newCTM),\n    willPan = this.isPanDifferent(newCTM);\n  if (willZoom || willPan) {\n    // Before zoom\n    if (willZoom) {\n      // If returns false then cancel zooming\n      if (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(newCTM.a)) === false) {\n        newCTM.a = newCTM.d = this.activeState.zoom;\n        willZoom = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onZoom(this.getRelativeZoom());\n      }\n    }\n\n    // Before pan\n    if (willPan) {\n      var preventPan = this.options.beforePan(this.getPan(), {\n          x: newCTM.e,\n          y: newCTM.f\n        }),\n        // If prevent pan is an object\n        preventPanX = false,\n        preventPanY = false;\n\n      // If prevent pan is Boolean false\n      if (preventPan === false) {\n        // Set x and y same as before\n        newCTM.e = this.getPan().x;\n        newCTM.f = this.getPan().y;\n        preventPanX = preventPanY = true;\n      } else if (Utils.isObject(preventPan)) {\n        // Check for X axes attribute\n        if (preventPan.x === false) {\n          // Prevent panning on x axes\n          newCTM.e = this.getPan().x;\n          preventPanX = true;\n        } else if (Utils.isNumber(preventPan.x)) {\n          // Set a custom pan value\n          newCTM.e = preventPan.x;\n        }\n\n        // Check for Y axes attribute\n        if (preventPan.y === false) {\n          // Prevent panning on x axes\n          newCTM.f = this.getPan().y;\n          preventPanY = true;\n        } else if (Utils.isNumber(preventPan.y)) {\n          // Set a custom pan value\n          newCTM.f = preventPan.y;\n        }\n      }\n\n      // Update willPan flag\n      // Check if newCTM is still different\n      if (preventPanX && preventPanY || !this.isPanDifferent(newCTM)) {\n        willPan = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onPan(this.getPan());\n      }\n    }\n\n    // Check again if should zoom or pan\n    if (willZoom || willPan) {\n      this.updateCTMOnNextFrame();\n    }\n  }\n};\nShadowViewport.prototype.isZoomDifferent = function (newCTM) {\n  return this.activeState.zoom !== newCTM.a;\n};\nShadowViewport.prototype.isPanDifferent = function (newCTM) {\n  return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;\n};\n\n/**\n * Update cached CTM and active state\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.updateCache = function (newCTM) {\n  this.activeState.zoom = newCTM.a;\n  this.activeState.x = newCTM.e;\n  this.activeState.y = newCTM.f;\n};\nShadowViewport.prototype.pendingUpdate = false;\n\n/**\n * Place a request to update CTM on next Frame\n */\nShadowViewport.prototype.updateCTMOnNextFrame = function () {\n  if (!this.pendingUpdate) {\n    // Lock\n    this.pendingUpdate = true;\n\n    // Throttle next update\n    this.requestAnimationFrame.call(window, this.updateCTMCached);\n  }\n};\n\n/**\n * Update viewport CTM with cached CTM\n */\nShadowViewport.prototype.updateCTM = function () {\n  var ctm = this.getCTM();\n\n  // Updates SVG element\n  SvgUtils.setCTM(this.viewport, ctm, this.defs);\n\n  // Free the lock\n  this.pendingUpdate = false;\n\n  // Notify about the update\n  if (this.options.onUpdatedCTM) {\n    this.options.onUpdatedCTM(ctm);\n  }\n};\nmodule.exports = function (viewport, options) {\n  return new ShadowViewport(viewport, options);\n};\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/svg-pan-zoom/src/shadow-viewport.js?");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/svg-pan-zoom.js":
/*!*******************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/svg-pan-zoom.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Wheel = __webpack_require__(/*! ./uniwheel */ \"./node_modules/svg-pan-zoom/src/uniwheel.js\"),\n  ControlIcons = __webpack_require__(/*! ./control-icons */ \"./node_modules/svg-pan-zoom/src/control-icons.js\"),\n  Utils = __webpack_require__(/*! ./utilities */ \"./node_modules/svg-pan-zoom/src/utilities.js\"),\n  SvgUtils = __webpack_require__(/*! ./svg-utilities */ \"./node_modules/svg-pan-zoom/src/svg-utilities.js\"),\n  ShadowViewport = __webpack_require__(/*! ./shadow-viewport */ \"./node_modules/svg-pan-zoom/src/shadow-viewport.js\");\nvar SvgPanZoom = function SvgPanZoom(svg, options) {\n  this.init(svg, options);\n};\nvar optionsDefaults = {\n  viewportSelector: \".svg-pan-zoom_viewport\",\n  // Viewport selector. Can be querySelector string or SVGElement\n  panEnabled: true,\n  // enable or disable panning (default enabled)\n  controlIconsEnabled: false,\n  // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)\n  zoomEnabled: true,\n  // enable or disable zooming (default enabled)\n  dblClickZoomEnabled: true,\n  // enable or disable zooming by double clicking (default enabled)\n  mouseWheelZoomEnabled: true,\n  // enable or disable zooming by mouse wheel (default enabled)\n  preventMouseEventsDefault: true,\n  // enable or disable preventDefault for mouse events\n  zoomScaleSensitivity: 0.1,\n  // Zoom sensitivity\n  minZoom: 0.5,\n  // Minimum Zoom level\n  maxZoom: 10,\n  // Maximum Zoom level\n  fit: true,\n  // enable or disable viewport fit in SVG (default true)\n  contain: false,\n  // enable or disable viewport contain the svg (default false)\n  center: true,\n  // enable or disable viewport centering in SVG (default true)\n  refreshRate: \"auto\",\n  // Maximum number of frames per second (altering SVG's viewport)\n  beforeZoom: null,\n  onZoom: null,\n  beforePan: null,\n  onPan: null,\n  customEventsHandler: null,\n  eventsListenerElement: null,\n  onUpdatedCTM: null\n};\nvar passiveListenerOption = {\n  passive: true\n};\nSvgPanZoom.prototype.init = function (svg, options) {\n  var that = this;\n  this.svg = svg;\n  this.defs = svg.querySelector(\"defs\");\n\n  // Add default attributes to SVG\n  SvgUtils.setupSvgAttributes(this.svg);\n\n  // Set options\n  this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);\n\n  // Set default state\n  this.state = \"none\";\n\n  // Get dimensions\n  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(svg);\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n\n  // Init shadow viewport\n  this.viewport = ShadowViewport(SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector), {\n    svg: this.svg,\n    width: this.width,\n    height: this.height,\n    fit: this.options.fit,\n    contain: this.options.contain,\n    center: this.options.center,\n    refreshRate: this.options.refreshRate,\n    // Put callbacks into functions as they can change through time\n    beforeZoom: function beforeZoom(oldScale, newScale) {\n      if (that.viewport && that.options.beforeZoom) {\n        return that.options.beforeZoom(oldScale, newScale);\n      }\n    },\n    onZoom: function onZoom(scale) {\n      if (that.viewport && that.options.onZoom) {\n        return that.options.onZoom(scale);\n      }\n    },\n    beforePan: function beforePan(oldPoint, newPoint) {\n      if (that.viewport && that.options.beforePan) {\n        return that.options.beforePan(oldPoint, newPoint);\n      }\n    },\n    onPan: function onPan(point) {\n      if (that.viewport && that.options.onPan) {\n        return that.options.onPan(point);\n      }\n    },\n    onUpdatedCTM: function onUpdatedCTM(ctm) {\n      if (that.viewport && that.options.onUpdatedCTM) {\n        return that.options.onUpdatedCTM(ctm);\n      }\n    }\n  });\n\n  // Wrap callbacks into public API context\n  var publicInstance = this.getPublicInstance();\n  publicInstance.setBeforeZoom(this.options.beforeZoom);\n  publicInstance.setOnZoom(this.options.onZoom);\n  publicInstance.setBeforePan(this.options.beforePan);\n  publicInstance.setOnPan(this.options.onPan);\n  publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM);\n  if (this.options.controlIconsEnabled) {\n    ControlIcons.enable(this);\n  }\n\n  // Init events handlers\n  this.lastMouseWheelEventTime = Date.now();\n  this.setupHandlers();\n};\n\n/**\n * Register event handlers\n */\nSvgPanZoom.prototype.setupHandlers = function () {\n  var that = this,\n    prevEvt = null; // use for touchstart event to detect double tap\n\n  this.eventListeners = {\n    // Mouse down group\n    mousedown: function mousedown(evt) {\n      var result = that.handleMouseDown(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n    touchstart: function touchstart(evt) {\n      var result = that.handleMouseDown(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n    // Mouse up group\n    mouseup: function mouseup(evt) {\n      return that.handleMouseUp(evt);\n    },\n    touchend: function touchend(evt) {\n      return that.handleMouseUp(evt);\n    },\n    // Mouse move group\n    mousemove: function mousemove(evt) {\n      return that.handleMouseMove(evt);\n    },\n    touchmove: function touchmove(evt) {\n      return that.handleMouseMove(evt);\n    },\n    // Mouse leave group\n    mouseleave: function mouseleave(evt) {\n      return that.handleMouseUp(evt);\n    },\n    touchleave: function touchleave(evt) {\n      return that.handleMouseUp(evt);\n    },\n    touchcancel: function touchcancel(evt) {\n      return that.handleMouseUp(evt);\n    }\n  };\n\n  // Init custom events handler if available\n  // eslint-disable-next-line eqeqeq\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.init({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance()\n    });\n\n    // Custom event handler may halt builtin listeners\n    var haltEventListeners = this.options.customEventsHandler.haltEventListeners;\n    if (haltEventListeners && haltEventListeners.length) {\n      for (var i = haltEventListeners.length - 1; i >= 0; i--) {\n        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {\n          delete this.eventListeners[haltEventListeners[i]];\n        }\n      }\n    }\n  }\n\n  // Bind eventListeners\n  for (var event in this.eventListeners) {\n    // Attach event to eventsListenerElement or SVG if not available\n    (this.options.eventsListenerElement || this.svg).addEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerOption : false);\n  }\n\n  // Zoom using mouse wheel\n  if (this.options.mouseWheelZoomEnabled) {\n    this.options.mouseWheelZoomEnabled = false; // set to false as enable will set it back to true\n    this.enableMouseWheelZoom();\n  }\n};\n\n/**\n * Enable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.enableMouseWheelZoom = function () {\n  if (!this.options.mouseWheelZoomEnabled) {\n    var that = this;\n\n    // Mouse wheel listener\n    this.wheelListener = function (evt) {\n      return that.handleMouseWheel(evt);\n    };\n\n    // Bind wheelListener\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.on(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);\n    this.options.mouseWheelZoomEnabled = true;\n  }\n};\n\n/**\n * Disable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.disableMouseWheelZoom = function () {\n  if (this.options.mouseWheelZoomEnabled) {\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.off(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);\n    this.options.mouseWheelZoomEnabled = false;\n  }\n};\n\n/**\n * Handle mouse wheel event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseWheel = function (evt) {\n  if (!this.options.zoomEnabled || this.state !== \"none\") {\n    return;\n  }\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  // Default delta in case that deltaY is not available\n  var delta = evt.deltaY || 1,\n    timeDelta = Date.now() - this.lastMouseWheelEventTime,\n    divider = 3 + Math.max(0, 30 - timeDelta);\n\n  // Update cache\n  this.lastMouseWheelEventTime = Date.now();\n\n  // Make empirical adjustments for browsers that give deltaY in pixels (deltaMode=0)\n  if (\"deltaMode\" in evt && evt.deltaMode === 0 && evt.wheelDelta) {\n    delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;\n  }\n  delta = -0.3 < delta && delta < 0.3 ? delta : (delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10) / divider;\n  var inversedScreenCTM = this.svg.getScreenCTM().inverse(),\n    relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(inversedScreenCTM),\n    zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta); // multiplying by neg. 1 so as to make zoom in/out behavior match Google maps behavior\n\n  this.zoomAtPoint(zoom, relativeMousePoint);\n};\n\n/**\n * Zoom in at a SVG point\n *\n * @param  {SVGPoint} point\n * @param  {Float} zoomScale    Number representing how much to zoom\n * @param  {Boolean} zoomAbsolute Default false. If true, zoomScale is treated as an absolute value.\n *                                Otherwise, zoomScale is treated as a multiplied (e.g. 1.10 would zoom in 10%)\n */\nSvgPanZoom.prototype.zoomAtPoint = function (zoomScale, point, zoomAbsolute) {\n  var originalState = this.viewport.getOriginalState();\n  if (!zoomAbsolute) {\n    // Fit zoomScale in set bounds\n    if (this.getZoom() * zoomScale < this.options.minZoom * originalState.zoom) {\n      zoomScale = this.options.minZoom * originalState.zoom / this.getZoom();\n    } else if (this.getZoom() * zoomScale > this.options.maxZoom * originalState.zoom) {\n      zoomScale = this.options.maxZoom * originalState.zoom / this.getZoom();\n    }\n  } else {\n    // Fit zoomScale in set bounds\n    zoomScale = Math.max(this.options.minZoom * originalState.zoom, Math.min(this.options.maxZoom * originalState.zoom, zoomScale));\n    // Find relative scale to achieve desired scale\n    zoomScale = zoomScale / this.getZoom();\n  }\n  var oldCTM = this.viewport.getCTM(),\n    relativePoint = point.matrixTransform(oldCTM.inverse()),\n    modifier = this.svg.createSVGMatrix().translate(relativePoint.x, relativePoint.y).scale(zoomScale).translate(-relativePoint.x, -relativePoint.y),\n    newCTM = oldCTM.multiply(modifier);\n  if (newCTM.a !== oldCTM.a) {\n    this.viewport.setCTM(newCTM);\n  }\n};\n\n/**\n * Zoom at center point\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.zoom = function (scale, absolute) {\n  this.zoomAtPoint(scale, SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height), absolute);\n};\n\n/**\n * Zoom used by public instance\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoom = function (scale, absolute) {\n  if (absolute) {\n    scale = this.computeFromRelativeZoom(scale);\n  }\n  this.zoom(scale, absolute);\n};\n\n/**\n * Zoom at point used by public instance\n *\n * @param  {Float} scale\n * @param  {SVGPoint|Object} point    An object that has x and y attributes\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoomAtPoint = function (scale, point, absolute) {\n  if (absolute) {\n    // Transform zoom into a relative value\n    scale = this.computeFromRelativeZoom(scale);\n  }\n\n  // If not a SVGPoint but has x and y then create a SVGPoint\n  if (Utils.getType(point) !== \"SVGPoint\") {\n    if (\"x\" in point && \"y\" in point) {\n      point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);\n    } else {\n      throw new Error(\"Given point is invalid\");\n    }\n  }\n  this.zoomAtPoint(scale, point, absolute);\n};\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getZoom = function () {\n  return this.viewport.getZoom();\n};\n\n/**\n * Get zoom scale for public usage\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getRelativeZoom = function () {\n  return this.viewport.getRelativeZoom();\n};\n\n/**\n * Compute actual zoom from public zoom\n *\n * @param  {Float} zoom\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.computeFromRelativeZoom = function (zoom) {\n  return zoom * this.viewport.getOriginalState().zoom;\n};\n\n/**\n * Set zoom to initial state\n */\nSvgPanZoom.prototype.resetZoom = function () {\n  var originalState = this.viewport.getOriginalState();\n  this.zoom(originalState.zoom, true);\n};\n\n/**\n * Set pan to initial state\n */\nSvgPanZoom.prototype.resetPan = function () {\n  this.pan(this.viewport.getOriginalState());\n};\n\n/**\n * Set pan and zoom to initial state\n */\nSvgPanZoom.prototype.reset = function () {\n  this.resetZoom();\n  this.resetPan();\n};\n\n/**\n * Handle double click event\n * See handleMouseDown() for alternate detection method\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleDblClick = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  // Check if target was a control button\n  if (this.options.controlIconsEnabled) {\n    var targetClass = evt.target.getAttribute(\"class\") || \"\";\n    if (targetClass.indexOf(\"svg-pan-zoom-control\") > -1) {\n      return false;\n    }\n  }\n  var zoomFactor;\n  if (evt.shiftKey) {\n    zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2); // zoom out when shift key pressed\n  } else {\n    zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;\n  }\n  var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.svg.getScreenCTM().inverse());\n  this.zoomAtPoint(zoomFactor, point);\n};\n\n/**\n * Handle click event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseDown = function (evt, prevEvt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n  Utils.mouseAndTouchNormalize(evt, this.svg);\n\n  // Double click detection; more consistent than ondblclick\n  if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {\n    this.handleDblClick(evt);\n  } else {\n    // Pan mode\n    this.state = \"pan\";\n    this.firstEventCTM = this.viewport.getCTM();\n    this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());\n  }\n};\n\n/**\n * Handle mouse move event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseMove = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n  if (this.state === \"pan\" && this.options.panEnabled) {\n    // Pan mode\n    var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse()),\n      viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);\n    this.viewport.setCTM(viewportCTM);\n  }\n};\n\n/**\n * Handle mouse button release event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseUp = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n  if (this.state === \"pan\") {\n    // Quit pan mode\n    this.state = \"none\";\n  }\n};\n\n/**\n * Adjust viewport size (only) so it will fit in SVG\n * Does not center image\n */\nSvgPanZoom.prototype.fit = function () {\n  var viewBox = this.viewport.getViewBox(),\n    newScale = Math.min(this.width / viewBox.width, this.height / viewBox.height);\n  this.zoom(newScale, true);\n};\n\n/**\n * Adjust viewport size (only) so it will contain the SVG\n * Does not center image\n */\nSvgPanZoom.prototype.contain = function () {\n  var viewBox = this.viewport.getViewBox(),\n    newScale = Math.max(this.width / viewBox.width, this.height / viewBox.height);\n  this.zoom(newScale, true);\n};\n\n/**\n * Adjust viewport pan (only) so it will be centered in SVG\n * Does not zoom/fit/contain image\n */\nSvgPanZoom.prototype.center = function () {\n  var viewBox = this.viewport.getViewBox(),\n    offsetX = (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5,\n    offsetY = (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5;\n  this.getPublicInstance().pan({\n    x: offsetX,\n    y: offsetY\n  });\n};\n\n/**\n * Update content cached BorderBox\n * Use when viewport contents change\n */\nSvgPanZoom.prototype.updateBBox = function () {\n  this.viewport.simpleViewBoxCache();\n};\n\n/**\n * Pan to a rendered position\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.pan = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e = point.x;\n  viewportCTM.f = point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\n/**\n * Relatively pan the graph by a specified rendered position vector\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.panBy = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e += point.x;\n  viewportCTM.f += point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\n/**\n * Get pan vector\n *\n * @return {Object} {x: 0, y: 0}\n */\nSvgPanZoom.prototype.getPan = function () {\n  var state = this.viewport.getState();\n  return {\n    x: state.x,\n    y: state.y\n  };\n};\n\n/**\n * Recalculates cached svg dimensions and controls position\n */\nSvgPanZoom.prototype.resize = function () {\n  // Get dimensions\n  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(this.svg);\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n\n  // Recalculate original state\n  var viewport = this.viewport;\n  viewport.options.width = this.width;\n  viewport.options.height = this.height;\n  viewport.processCTM();\n\n  // Reposition control icons by re-enabling them\n  if (this.options.controlIconsEnabled) {\n    this.getPublicInstance().disableControlIcons();\n    this.getPublicInstance().enableControlIcons();\n  }\n};\n\n/**\n * Unbind mouse events, free callbacks and destroy public instance\n */\nSvgPanZoom.prototype.destroy = function () {\n  var that = this;\n\n  // Free callbacks\n  this.beforeZoom = null;\n  this.onZoom = null;\n  this.beforePan = null;\n  this.onPan = null;\n  this.onUpdatedCTM = null;\n\n  // Destroy custom event handlers\n  // eslint-disable-next-line eqeqeq\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.destroy({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance()\n    });\n  }\n\n  // Unbind eventListeners\n  for (var event in this.eventListeners) {\n    (this.options.eventsListenerElement || this.svg).removeEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerOption : false);\n  }\n\n  // Unbind wheelListener\n  this.disableMouseWheelZoom();\n\n  // Remove control icons\n  this.getPublicInstance().disableControlIcons();\n\n  // Reset zoom and pan\n  this.reset();\n\n  // Remove instance from instancesStore\n  instancesStore = instancesStore.filter(function (instance) {\n    return instance.svg !== that.svg;\n  });\n\n  // Delete options and its contents\n  delete this.options;\n\n  // Delete viewport to make public shadow viewport functions uncallable\n  delete this.viewport;\n\n  // Destroy public instance and rewrite getPublicInstance\n  delete this.publicInstance;\n  delete this.pi;\n  this.getPublicInstance = function () {\n    return null;\n  };\n};\n\n/**\n * Returns a public instance object\n *\n * @return {Object} Public instance object\n */\nSvgPanZoom.prototype.getPublicInstance = function () {\n  var that = this;\n\n  // Create cache\n  if (!this.publicInstance) {\n    this.publicInstance = this.pi = {\n      // Pan\n      enablePan: function enablePan() {\n        that.options.panEnabled = true;\n        return that.pi;\n      },\n      disablePan: function disablePan() {\n        that.options.panEnabled = false;\n        return that.pi;\n      },\n      isPanEnabled: function isPanEnabled() {\n        return !!that.options.panEnabled;\n      },\n      pan: function pan(point) {\n        that.pan(point);\n        return that.pi;\n      },\n      panBy: function panBy(point) {\n        that.panBy(point);\n        return that.pi;\n      },\n      getPan: function getPan() {\n        return that.getPan();\n      },\n      // Pan event\n      setBeforePan: function setBeforePan(fn) {\n        that.options.beforePan = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnPan: function setOnPan(fn) {\n        that.options.onPan = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Zoom and Control Icons\n      enableZoom: function enableZoom() {\n        that.options.zoomEnabled = true;\n        return that.pi;\n      },\n      disableZoom: function disableZoom() {\n        that.options.zoomEnabled = false;\n        return that.pi;\n      },\n      isZoomEnabled: function isZoomEnabled() {\n        return !!that.options.zoomEnabled;\n      },\n      enableControlIcons: function enableControlIcons() {\n        if (!that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = true;\n          ControlIcons.enable(that);\n        }\n        return that.pi;\n      },\n      disableControlIcons: function disableControlIcons() {\n        if (that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = false;\n          ControlIcons.disable(that);\n        }\n        return that.pi;\n      },\n      isControlIconsEnabled: function isControlIconsEnabled() {\n        return !!that.options.controlIconsEnabled;\n      },\n      // Double click zoom\n      enableDblClickZoom: function enableDblClickZoom() {\n        that.options.dblClickZoomEnabled = true;\n        return that.pi;\n      },\n      disableDblClickZoom: function disableDblClickZoom() {\n        that.options.dblClickZoomEnabled = false;\n        return that.pi;\n      },\n      isDblClickZoomEnabled: function isDblClickZoomEnabled() {\n        return !!that.options.dblClickZoomEnabled;\n      },\n      // Mouse wheel zoom\n      enableMouseWheelZoom: function enableMouseWheelZoom() {\n        that.enableMouseWheelZoom();\n        return that.pi;\n      },\n      disableMouseWheelZoom: function disableMouseWheelZoom() {\n        that.disableMouseWheelZoom();\n        return that.pi;\n      },\n      isMouseWheelZoomEnabled: function isMouseWheelZoomEnabled() {\n        return !!that.options.mouseWheelZoomEnabled;\n      },\n      // Zoom scale and bounds\n      setZoomScaleSensitivity: function setZoomScaleSensitivity(scale) {\n        that.options.zoomScaleSensitivity = scale;\n        return that.pi;\n      },\n      setMinZoom: function setMinZoom(zoom) {\n        that.options.minZoom = zoom;\n        return that.pi;\n      },\n      setMaxZoom: function setMaxZoom(zoom) {\n        that.options.maxZoom = zoom;\n        return that.pi;\n      },\n      // Zoom event\n      setBeforeZoom: function setBeforeZoom(fn) {\n        that.options.beforeZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnZoom: function setOnZoom(fn) {\n        that.options.onZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Zooming\n      zoom: function zoom(scale) {\n        that.publicZoom(scale, true);\n        return that.pi;\n      },\n      zoomBy: function zoomBy(scale) {\n        that.publicZoom(scale, false);\n        return that.pi;\n      },\n      zoomAtPoint: function zoomAtPoint(scale, point) {\n        that.publicZoomAtPoint(scale, point, true);\n        return that.pi;\n      },\n      zoomAtPointBy: function zoomAtPointBy(scale, point) {\n        that.publicZoomAtPoint(scale, point, false);\n        return that.pi;\n      },\n      zoomIn: function zoomIn() {\n        this.zoomBy(1 + that.options.zoomScaleSensitivity);\n        return that.pi;\n      },\n      zoomOut: function zoomOut() {\n        this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));\n        return that.pi;\n      },\n      getZoom: function getZoom() {\n        return that.getRelativeZoom();\n      },\n      // CTM update\n      setOnUpdatedCTM: function setOnUpdatedCTM(fn) {\n        that.options.onUpdatedCTM = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Reset\n      resetZoom: function resetZoom() {\n        that.resetZoom();\n        return that.pi;\n      },\n      resetPan: function resetPan() {\n        that.resetPan();\n        return that.pi;\n      },\n      reset: function reset() {\n        that.reset();\n        return that.pi;\n      },\n      // Fit, Contain and Center\n      fit: function fit() {\n        that.fit();\n        return that.pi;\n      },\n      contain: function contain() {\n        that.contain();\n        return that.pi;\n      },\n      center: function center() {\n        that.center();\n        return that.pi;\n      },\n      // Size and Resize\n      updateBBox: function updateBBox() {\n        that.updateBBox();\n        return that.pi;\n      },\n      resize: function resize() {\n        that.resize();\n        return that.pi;\n      },\n      getSizes: function getSizes() {\n        return {\n          width: that.width,\n          height: that.height,\n          realZoom: that.getZoom(),\n          viewBox: that.viewport.getViewBox()\n        };\n      },\n      // Destroy\n      destroy: function destroy() {\n        that.destroy();\n        return that.pi;\n      }\n    };\n  }\n  return this.publicInstance;\n};\n\n/**\n * Stores pairs of instances of SvgPanZoom and SVG\n * Each pair is represented by an object {svg: SVGSVGElement, instance: SvgPanZoom}\n *\n * @type {Array}\n */\nvar instancesStore = [];\nvar svgPanZoom = function svgPanZoom(elementOrSelector, options) {\n  var svg = Utils.getSvg(elementOrSelector);\n  if (svg === null) {\n    return null;\n  } else {\n    // Look for existent instance\n    for (var i = instancesStore.length - 1; i >= 0; i--) {\n      if (instancesStore[i].svg === svg) {\n        return instancesStore[i].instance.getPublicInstance();\n      }\n    }\n\n    // If instance not found - create one\n    instancesStore.push({\n      svg: svg,\n      instance: new SvgPanZoom(svg, options)\n    });\n\n    // Return just pushed instance\n    return instancesStore[instancesStore.length - 1].instance.getPublicInstance();\n  }\n};\nmodule.exports = svgPanZoom;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/svg-pan-zoom/src/svg-pan-zoom.js?");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/svg-utilities.js":
/*!********************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/svg-utilities.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ./utilities */ \"./node_modules/svg-pan-zoom/src/utilities.js\"),\n  _browser = \"unknown\";\n\n// http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\nif ( /*@cc_on!@*/ false || !!document.documentMode) {\n  // internet explorer\n  _browser = \"ie\";\n}\nmodule.exports = {\n  svgNS: \"http://www.w3.org/2000/svg\",\n  xmlNS: \"http://www.w3.org/XML/1998/namespace\",\n  xmlnsNS: \"http://www.w3.org/2000/xmlns/\",\n  xlinkNS: \"http://www.w3.org/1999/xlink\",\n  evNS: \"http://www.w3.org/2001/xml-events\",\n  /**\n   * Get svg dimensions: width and height\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {Object}     {width: 0, height: 0}\n   */\n  getBoundingClientRectNormalized: function getBoundingClientRectNormalized(svg) {\n    if (svg.clientWidth && svg.clientHeight) {\n      return {\n        width: svg.clientWidth,\n        height: svg.clientHeight\n      };\n    } else if (!!svg.getBoundingClientRect()) {\n      return svg.getBoundingClientRect();\n    } else {\n      throw new Error(\"Cannot get BoundingClientRect for SVG.\");\n    }\n  },\n  /**\n   * Gets g element with class of \"viewport\" or creates it if it doesn't exist\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGElement}     g (group) element\n   */\n  getOrCreateViewport: function getOrCreateViewport(svg, selector) {\n    var viewport = null;\n    if (Utils.isElement(selector)) {\n      viewport = selector;\n    } else {\n      viewport = svg.querySelector(selector);\n    }\n\n    // Check if there is just one main group in SVG\n    if (!viewport) {\n      var childNodes = Array.prototype.slice.call(svg.childNodes || svg.children).filter(function (el) {\n        return el.nodeName !== \"defs\" && el.nodeName !== \"#text\";\n      });\n\n      // Node name should be SVGGElement and should have no transform attribute\n      // Groups with transform are not used as viewport because it involves parsing of all transform possibilities\n      if (childNodes.length === 1 && childNodes[0].nodeName === \"g\" && childNodes[0].getAttribute(\"transform\") === null) {\n        viewport = childNodes[0];\n      }\n    }\n\n    // If no favorable group element exists then create one\n    if (!viewport) {\n      var viewportId = \"viewport-\" + new Date().toISOString().replace(/\\D/g, \"\");\n      viewport = document.createElementNS(this.svgNS, \"g\");\n      viewport.setAttribute(\"id\", viewportId);\n\n      // Internet Explorer (all versions?) can't use childNodes, but other browsers prefer (require?) using childNodes\n      var svgChildren = svg.childNodes || svg.children;\n      if (!!svgChildren && svgChildren.length > 0) {\n        for (var i = svgChildren.length; i > 0; i--) {\n          // Move everything into viewport except defs\n          if (svgChildren[svgChildren.length - i].nodeName !== \"defs\") {\n            viewport.appendChild(svgChildren[svgChildren.length - i]);\n          }\n        }\n      }\n      svg.appendChild(viewport);\n    }\n\n    // Parse class names\n    var classNames = [];\n    if (viewport.getAttribute(\"class\")) {\n      classNames = viewport.getAttribute(\"class\").split(\" \");\n    }\n\n    // Set class (if not set already)\n    if (!~classNames.indexOf(\"svg-pan-zoom_viewport\")) {\n      classNames.push(\"svg-pan-zoom_viewport\");\n      viewport.setAttribute(\"class\", classNames.join(\" \"));\n    }\n    return viewport;\n  },\n  /**\n   * Set SVG attributes\n   *\n   * @param  {SVGSVGElement} svg\n   */\n  setupSvgAttributes: function setupSvgAttributes(svg) {\n    // Setting default attributes\n    svg.setAttribute(\"xmlns\", this.svgNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:xlink\", this.xlinkNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:ev\", this.evNS);\n\n    // Needed for Internet Explorer, otherwise the viewport overflows\n    if (svg.parentNode !== null) {\n      var style = svg.getAttribute(\"style\") || \"\";\n      if (style.toLowerCase().indexOf(\"overflow\") === -1) {\n        svg.setAttribute(\"style\", \"overflow: hidden; \" + style);\n      }\n    }\n  },\n  /**\n   * How long Internet Explorer takes to finish updating its display (ms).\n   */\n  internetExplorerRedisplayInterval: 300,\n  /**\n   * Forces the browser to redisplay all SVG elements that rely on an\n   * element defined in a 'defs' section. It works globally, for every\n   * available defs element on the page.\n   * The throttling is intentionally global.\n   *\n   * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)\n   * visible after pan/zoom when there are multiple SVGs on the page.\n   * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/\n   * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62\n   */\n  refreshDefsGlobal: Utils.throttle(function () {\n    var allDefs = document.querySelectorAll(\"defs\");\n    var allDefsCount = allDefs.length;\n    for (var i = 0; i < allDefsCount; i++) {\n      var thisDefs = allDefs[i];\n      thisDefs.parentNode.insertBefore(thisDefs, thisDefs);\n    }\n  }, this ? this.internetExplorerRedisplayInterval : null),\n  /**\n   * Sets the current transform matrix of an element\n   *\n   * @param {SVGElement} element\n   * @param {SVGMatrix} matrix  CTM\n   * @param {SVGElement} defs\n   */\n  setCTM: function setCTM(element, matrix, defs) {\n    var that = this,\n      s = \"matrix(\" + matrix.a + \",\" + matrix.b + \",\" + matrix.c + \",\" + matrix.d + \",\" + matrix.e + \",\" + matrix.f + \")\";\n    element.setAttributeNS(null, \"transform\", s);\n    if (\"transform\" in element.style) {\n      element.style.transform = s;\n    } else if (\"-ms-transform\" in element.style) {\n      element.style[\"-ms-transform\"] = s;\n    } else if (\"-webkit-transform\" in element.style) {\n      element.style[\"-webkit-transform\"] = s;\n    }\n\n    // IE has a bug that makes markers disappear on zoom (when the matrix \"a\" and/or \"d\" elements change)\n    // see http://stackoverflow.com/questions/17654578/svg-marker-does-not-work-in-ie9-10\n    // and http://srndolha.wordpress.com/2013/11/25/svg-line-markers-may-disappear-in-internet-explorer-11/\n    if (_browser === \"ie\" && !!defs) {\n      // this refresh is intended for redisplaying the SVG during zooming\n      defs.parentNode.insertBefore(defs, defs);\n      // this refresh is intended for redisplaying the other SVGs on a page when panning a given SVG\n      // it is also needed for the given SVG itself, on zoomEnd, if the SVG contains any markers that\n      // are located under any other element(s).\n      window.setTimeout(function () {\n        that.refreshDefsGlobal();\n      }, that.internetExplorerRedisplayInterval);\n    }\n  },\n  /**\n   * Instantiate an SVGPoint object with given event coordinates\n   *\n   * @param {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}     point\n   */\n  getEventPoint: function getEventPoint(evt, svg) {\n    var point = svg.createSVGPoint();\n    Utils.mouseAndTouchNormalize(evt, svg);\n    point.x = evt.clientX;\n    point.y = evt.clientY;\n    return point;\n  },\n  /**\n   * Get SVG center point\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}\n   */\n  getSvgCenterPoint: function getSvgCenterPoint(svg, width, height) {\n    return this.createSVGPoint(svg, width / 2, height / 2);\n  },\n  /**\n   * Create a SVGPoint with given x and y\n   *\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {SVGPoint}\n   */\n  createSVGPoint: function createSVGPoint(svg, x, y) {\n    var point = svg.createSVGPoint();\n    point.x = x;\n    point.y = y;\n    return point;\n  }\n};\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/svg-pan-zoom/src/svg-utilities.js?");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/uniwheel.js":
/*!***************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/uniwheel.js ***!
  \***************************************************/
/***/ ((module) => {

eval("// uniwheel 0.1.2 (customized)\n// A unified cross browser mouse wheel event handler\n// https://github.com/teemualap/uniwheel\n\nmodule.exports = function () {\n  //Full details: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel\n\n  var prefix = \"\",\n    _addEventListener,\n    _removeEventListener,\n    support,\n    fns = [];\n  var passiveOption = {\n    passive: true\n  };\n\n  // detect event model\n  if (window.addEventListener) {\n    _addEventListener = \"addEventListener\";\n    _removeEventListener = \"removeEventListener\";\n  } else {\n    _addEventListener = \"attachEvent\";\n    _removeEventListener = \"detachEvent\";\n    prefix = \"on\";\n  }\n\n  // detect available wheel event\n  support = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" :\n  // Modern browsers support \"wheel\"\n  document.onmousewheel !== undefined ? \"mousewheel\" :\n  // Webkit and IE support at least \"mousewheel\"\n  \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\n  function createCallback(element, callback) {\n    var fn = function fn(originalEvent) {\n      !originalEvent && (originalEvent = window.event);\n\n      // create a normalized event object\n      var event = {\n        // keep a ref to the original event object\n        originalEvent: originalEvent,\n        target: originalEvent.target || originalEvent.srcElement,\n        type: \"wheel\",\n        deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\n        deltaX: 0,\n        delatZ: 0,\n        preventDefault: function preventDefault() {\n          originalEvent.preventDefault ? originalEvent.preventDefault() : originalEvent.returnValue = false;\n        }\n      };\n\n      // calculate deltaY (and deltaX) according to the event\n      if (support == \"mousewheel\") {\n        event.deltaY = -1 / 40 * originalEvent.wheelDelta;\n        // Webkit also support wheelDeltaX\n        originalEvent.wheelDeltaX && (event.deltaX = -1 / 40 * originalEvent.wheelDeltaX);\n      } else {\n        event.deltaY = originalEvent.detail;\n      }\n\n      // it's time to fire the callback\n      return callback(event);\n    };\n    fns.push({\n      element: element,\n      fn: fn\n    });\n    return fn;\n  }\n  function getCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns[i].fn;\n      }\n    }\n    return function () {};\n  }\n  function removeCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns.splice(i, 1);\n      }\n    }\n  }\n  function _addWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n    if (support === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = createCallback(elem, callback);\n    }\n    elem[_addEventListener](prefix + eventName, cb, isPassiveListener ? passiveOption : false);\n  }\n  function _removeWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n    if (support === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = getCallback(elem);\n    }\n    elem[_removeEventListener](prefix + eventName, cb, isPassiveListener ? passiveOption : false);\n    removeCallback(elem);\n  }\n  function addWheelListener(elem, callback, isPassiveListener) {\n    _addWheelListener(elem, support, callback, isPassiveListener);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (support == \"DOMMouseScroll\") {\n      _addWheelListener(elem, \"MozMousePixelScroll\", callback, isPassiveListener);\n    }\n  }\n  function removeWheelListener(elem, callback, isPassiveListener) {\n    _removeWheelListener(elem, support, callback, isPassiveListener);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (support == \"DOMMouseScroll\") {\n      _removeWheelListener(elem, \"MozMousePixelScroll\", callback, isPassiveListener);\n    }\n  }\n  return {\n    on: addWheelListener,\n    off: removeWheelListener\n  };\n}();\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/svg-pan-zoom/src/uniwheel.js?");

/***/ }),

/***/ "./node_modules/svg-pan-zoom/src/utilities.js":
/*!****************************************************!*\
  !*** ./node_modules/svg-pan-zoom/src/utilities.js ***!
  \****************************************************/
/***/ ((module) => {

eval("module.exports = {\n  /**\n   * Extends an object\n   *\n   * @param  {Object} target object to extend\n   * @param  {Object} source object to take properties from\n   * @return {Object}        extended object\n   */\n  extend: function extend(target, source) {\n    target = target || {};\n    for (var prop in source) {\n      // Go recursively\n      if (this.isObject(source[prop])) {\n        target[prop] = this.extend(target[prop], source[prop]);\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n    return target;\n  },\n  /**\n   * Checks if an object is a DOM element\n   *\n   * @param  {Object}  o HTML element or String\n   * @return {Boolean}   returns true if object is a DOM element\n   */\n  isElement: function isElement(o) {\n    return o instanceof HTMLElement || o instanceof SVGElement || o instanceof SVGSVGElement ||\n    //DOM2\n    o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n  },\n  /**\n   * Checks if an object is an Object\n   *\n   * @param  {Object}  o Object\n   * @return {Boolean}   returns true if object is an Object\n   */\n  isObject: function isObject(o) {\n    return Object.prototype.toString.call(o) === \"[object Object]\";\n  },\n  /**\n   * Checks if variable is Number\n   *\n   * @param  {Integer|Float}  n\n   * @return {Boolean}   returns true if variable is Number\n   */\n  isNumber: function isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  },\n  /**\n   * Search for an SVG element\n   *\n   * @param  {Object|String} elementOrSelector DOM Element or selector String\n   * @return {Object|Null}                   SVG or null\n   */\n  getSvg: function getSvg(elementOrSelector) {\n    var element, svg;\n    if (!this.isElement(elementOrSelector)) {\n      // If selector provided\n      if (typeof elementOrSelector === \"string\" || elementOrSelector instanceof String) {\n        // Try to find the element\n        element = document.querySelector(elementOrSelector);\n        if (!element) {\n          throw new Error(\"Provided selector did not find any elements. Selector: \" + elementOrSelector);\n          return null;\n        }\n      } else {\n        throw new Error(\"Provided selector is not an HTML object nor String\");\n        return null;\n      }\n    } else {\n      element = elementOrSelector;\n    }\n    if (element.tagName.toLowerCase() === \"svg\") {\n      svg = element;\n    } else {\n      if (element.tagName.toLowerCase() === \"object\") {\n        svg = element.contentDocument.documentElement;\n      } else {\n        if (element.tagName.toLowerCase() === \"embed\") {\n          svg = element.getSVGDocument().documentElement;\n        } else {\n          if (element.tagName.toLowerCase() === \"img\") {\n            throw new Error('Cannot script an SVG in an \"img\" element. Please use an \"object\" element or an in-line SVG.');\n          } else {\n            throw new Error(\"Cannot get SVG.\");\n          }\n          return null;\n        }\n      }\n    }\n    return svg;\n  },\n  /**\n   * Attach a given context to a function\n   * @param  {Function} fn      Function\n   * @param  {Object}   context Context\n   * @return {Function}           Function with certain context\n   */\n  proxy: function proxy(fn, context) {\n    return function () {\n      return fn.apply(context, arguments);\n    };\n  },\n  /**\n   * Returns object type\n   * Uses toString that returns [object SVGPoint]\n   * And than parses object type from string\n   *\n   * @param  {Object} o Any object\n   * @return {String}   Object type\n   */\n  getType: function getType(o) {\n    return Object.prototype.toString.apply(o).replace(/^\\[object\\s/, \"\").replace(/\\]$/, \"\");\n  },\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   */\n  mouseAndTouchNormalize: function mouseAndTouchNormalize(evt, svg) {\n    // If no clientX then fallback\n    if (evt.clientX === void 0 || evt.clientX === null) {\n      // Fallback\n      evt.clientX = 0;\n      evt.clientY = 0;\n\n      // If it is a touch event\n      if (evt.touches !== void 0 && evt.touches.length) {\n        if (evt.touches[0].clientX !== void 0) {\n          evt.clientX = evt.touches[0].clientX;\n          evt.clientY = evt.touches[0].clientY;\n        } else if (evt.touches[0].pageX !== void 0) {\n          var rect = svg.getBoundingClientRect();\n          evt.clientX = evt.touches[0].pageX - rect.left;\n          evt.clientY = evt.touches[0].pageY - rect.top;\n        }\n        // If it is a custom event\n      } else if (evt.originalEvent !== void 0) {\n        if (evt.originalEvent.clientX !== void 0) {\n          evt.clientX = evt.originalEvent.clientX;\n          evt.clientY = evt.originalEvent.clientY;\n        }\n      }\n    }\n  },\n  /**\n   * Check if an event is a double click/tap\n   * TODO: For touch gestures use a library (hammer.js) that takes in account other events\n   * (touchmove and touchend). It should take in account tap duration and traveled distance\n   *\n   * @param  {Event}  evt\n   * @param  {Event}  prevEvt Previous Event\n   * @return {Boolean}\n   */\n  isDblClick: function isDblClick(evt, prevEvt) {\n    // Double click detected by browser\n    if (evt.detail === 2) {\n      return true;\n    }\n    // Try to compare events\n    else if (prevEvt !== void 0 && prevEvt !== null) {\n      var timeStampDiff = evt.timeStamp - prevEvt.timeStamp,\n        // should be lower than 250 ms\n        touchesDistance = Math.sqrt(Math.pow(evt.clientX - prevEvt.clientX, 2) + Math.pow(evt.clientY - prevEvt.clientY, 2));\n      return timeStampDiff < 250 && touchesDistance < 10;\n    }\n\n    // Nothing found\n    return false;\n  },\n  /**\n   * Returns current timestamp as an integer\n   *\n   * @return {Number}\n   */\n  now: Date.now || function () {\n    return new Date().getTime();\n  },\n  // From underscore.\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  throttle: function throttle(func, wait, options) {\n    var that = this;\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) {\n      options = {};\n    }\n    var later = function later() {\n      previous = options.leading === false ? 0 : that.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = args = null;\n      }\n    };\n    return function () {\n      var now = that.now();\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n      var remaining = wait - (now - previous);\n      context = this; // eslint-disable-line consistent-this\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) {\n          context = args = null;\n        }\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  },\n  /**\n   * Create a requestAnimationFrame simulation\n   *\n   * @param  {Number|String} refreshRate\n   * @return {Function}\n   */\n  createRequestAnimationFrame: function createRequestAnimationFrame(refreshRate) {\n    var timeout = null;\n\n    // Convert refreshRate to timeout\n    if (refreshRate !== \"auto\" && refreshRate < 60 && refreshRate > 1) {\n      timeout = Math.floor(1000 / refreshRate);\n    }\n    if (timeout === null) {\n      return window.requestAnimationFrame || requestTimeout(33);\n    } else {\n      return requestTimeout(timeout);\n    }\n  }\n};\n\n/**\n * Create a callback that will execute after a given timeout\n *\n * @param  {Function} timeout\n * @return {Function}\n */\nfunction requestTimeout(timeout) {\n  return function (callback) {\n    window.setTimeout(callback, timeout);\n  };\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/svg-pan-zoom/src/utilities.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./RoomAvailabilityMapAndRouter/styles.css":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./RoomAvailabilityMapAndRouter/styles.css ***!
  \******************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ``, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./RoomAvailabilityMapAndRouter/styles.css?./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./RoomAvailabilityMapAndRouter/styles.css":
/*!*************************************************!*\
  !*** ./RoomAvailabilityMapAndRouter/styles.css ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!../node_modules/sass-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./RoomAvailabilityMapAndRouter/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./RoomAvailabilityMapAndRouter/styles.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = React;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./RoomAvailabilityMapAndRouter/index.ts");
/******/ 	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = __webpack_exports__;
/******/ 	
/******/ })()
;
if (window.ComponentFramework && window.ComponentFramework.registerControl) {
	ComponentFramework.registerControl('ltc.RoomAvailabilityMapAndRouter', pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.RoomAvailabilityMapAndRouter);
} else {
	var ltc = ltc || {};
	ltc.RoomAvailabilityMapAndRouter = pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.RoomAvailabilityMapAndRouter;
	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = undefined;
}